# Initialize the data list
data_list <- list()
# Helper function to create a matrix from a data frame
create_matrix <- function(df, value_var, n_trials) {
df %>%
select(sid, trial, !!sym(value_var)) %>%
pivot_wider(names_from = trial, values_from = !!sym(value_var), names_prefix = "trial_") %>%
select(-sid) %>%
as.matrix() %>%
unname()
}
# Process requested parameters
for (param in data_params) {
switch(param,
"N" = if (is_group) data_list$N <- as.integer(length(unique(data$sid))),
"T" = {
data_list$T <- as.integer(n_trials)
if (is_group) data_list$Tsubj <- as.integer(rep(n_trials, length(unique(data$sid))))
},
"shown" = data_list$shown <- if (is_group) as.matrix(create_matrix(data, "v_targetdeck", n_trials)) else as.vector(as.integer(data$v_targetdeck)),
"outcome" = data_list$outcome <- if (is_group) as.matrix(create_matrix(data, "v_netchange", n_trials)) else as.vector(as.numeric(data$v_netchange)),
"Nplay" = data_list$Nplay <- if (is_group) as.integer(rowSums(data_list$choice == 1, na.rm = TRUE)) else as.integer(sum(data$v_response == 2, na.rm = TRUE)),
"Npass" = data_list$Npass <- if (is_group) as.integer(rowSums(data_list$choice == 0, na.rm = TRUE)) else as.integer(sum(data$v_response == 1, na.rm = TRUE)),
"RT" = {
data_list$RT <- if (is_group) as.matrix(create_matrix(data, "RT", n_trials)) else as.vector(as.numeric(data$RT))
if (use_percentile) {
all_RTs <- as.vector(data_list$RT)
RTbound <- as.numeric(quantile(head(sort(all_RTs), 100), 0.01))
} else if (rt_method == "adaptive") {
RTbound <- as.numeric(min(data_list$RT, na.rm = TRUE) - 1e-5)  # small epsilon
} else {
RTbound <- as.numeric(RTbound_ms) / 1000
}
data_list$RTbound <- as.numeric(RTbound)
data_list$minRT <- if (is_group) as.numeric(apply(data_list$RT, 1, min, na.rm = TRUE)) else as.numeric(min(data_list$RT, na.rm = TRUE))
data_list$minRT = data_list$minRT + pmax(minrt_ep_ms/1000, 0)
},
"RTplay" = {
RT_mat <- if (is_group) as.matrix(create_matrix(data, "RT", n_trials)) else matrix(as.numeric(data$RT), nrow = 1)
choice_mat <- if (is_group) data_list$choice else matrix(as.integer(data$v_response - 1), nrow = 1)
data_list$RTplay <- RT_mat
data_list$RTplay[choice_mat != 1] <- NA
if (is_group) {
data_list$RTplay <- t(apply(data_list$RTplay, 1, function(x) c(na.omit(x), rep(NA, sum(is.na(x))))))
} else {
data_list$RTplay <- c(na.omit(as.vector(data_list$RTplay)), rep(NA, sum(is.na(data_list$RTplay))))
}
data_list$RTplay <- as.matrix(data_list$RTplay)
},
"RTpass" = {
RT_mat <- if (is_group) as.matrix(create_matrix(data, "RT", n_trials)) else matrix(as.numeric(data$RT), nrow = 1)
choice_mat <- if (is_group) data_list$choice else matrix(as.integer(data$v_response - 1), nrow = 1)
data_list$RTpass <- RT_mat
data_list$RTpass[choice_mat != 0] <- NA
if (is_group) {
data_list$RTpass <- t(apply(data_list$RTpass, 1, function(x) c(na.omit(x), rep(NA, sum(is.na(x))))))
} else {
data_list$RTpass <- c(na.omit(as.vector(data_list$RTpass)), rep(NA, sum(is.na(data_list$RTpass))))
}
data_list$RTpass <- as.matrix(data_list$RTpass)
},
"choice" = data_list$choice <- get_choice_data(data, data_list, is_group, n_trials),
"is_pos" = data_list$is_pos <- calculate_is_pos(data, data_list, is_group, n_trials),
"is_net" = data_list$is_net <- calculate_is_net(data, data_list, is_group, n_trials),
"shown_mat" = data_list$shown_mat <- calculate_shown_mat(data, data_list, is_group, n_trials),
"decay_str" = data_list$decay_str <- calculate_decay_str(data, data_list, is_group, n_trials)
)
}
return(data_list)
}
# Helper function to get choice data
get_choice_data <- function(data, data_list, is_group, n_trials) {
if ("choice" %in% names(data_list)) {
return(data_list$choice)
} else {
if (is_group) {
return(as.matrix(create_matrix(data, "v_response", n_trials) - 1))
} else {
return(as.vector(as.integer(data$v_response - 1)))
}
}
}
# Calculate is_pos
calculate_is_pos <- function(data, data_list, is_group, n_trials) {
if (is_group) {
return(as.matrix((create_matrix(data, "v_netchange", n_trials) > 0) + 0))
} else {
return(as.integer(data$v_netchange > 0))
}
}
# Calculate is_net
calculate_is_net <- function(data, data_list, is_group, n_trials) {
if (is_group) {
return(as.matrix(create_matrix(data, "v_netchange", n_trials)))
} else {
return(as.vector(as.numeric(data$v_netchange)))
}
}
# Calculate shown_mat
calculate_shown_mat <- function(data, data_list, is_group, n_trials) {
if (is_group) {
shown_mat_list <- lapply(split(data, data$sid), function(sub_data) {
do.call(rbind, lapply(sub_data$v_targetdeck, function(x) t(as.numeric(as.matrix(1:4 == x)))))
})
return(array(unlist(shown_mat_list), dim = c(n_trials, 4, length(shown_mat_list))))
} else {
return(do.call(rbind, lapply(data$v_targetdeck, function(x) t(as.numeric(as.matrix(1:4 == x))))))
}
}
# Calculate decay_str
calculate_decay_str <- function(data, data_list, is_group, n_trials) {
create_permutation_matrix <- function(update_indices, T) {
perm_matrix <- matrix(0, nrow=T, ncol=T)
for (i in 1:length(update_indices)) {
start <- update_indices[i]
end <- if (i < length(update_indices)) update_indices[i+1] - 1 else T
perm_matrix[start:end, start] <- 1
}
return(perm_matrix)
}
calculate_single_decay_str <- function(sub_data, T) {
index_matrix <- outer(0:(T-1), 0:(T-1), `-`)
index_matrix[index_matrix < 0] <- 0
cumulative_effect_exp <- index_matrix
shown_mat <- do.call(rbind, lapply(sub_data$v_targetdeck, function(x) t(as.numeric(as.matrix(1:4 == x)))))
shown_mat_ev <- shown_mat * (as.integer(sub_data$v_response) - 1)
modified_cumulative_effect_exp <- array(0, dim=c(T, T, 4))
for (deck in 1:4) {
update_indices <- which(shown_mat_ev[, deck] != 0)
if (length(update_indices) > 0) {
perm_matrix <- create_permutation_matrix(update_indices, T)
modified_cumulative_effect_exp[,,deck] <- t(cumulative_effect_exp) %*% t(perm_matrix)
}
}
return(modified_cumulative_effect_exp)
}
if (is_group) {
decay_str_list <- lapply(split(data, data$sid), function(sub_data) {
calculate_single_decay_str(sub_data, n_trials)
})
return(array(unlist(decay_str_list), dim = c(n_trials, n_trials, 4, length(decay_str_list))))
} else {
return(calculate_single_decay_str(data, n_trials))
}
}
preprocess_data <- function(data, RTbound_ms, rt_method = "remove") {
# Ensure data is a data frame
data <- as.data.frame(data)
# Convert columns to appropriate types
data <- data %>%
mutate(
sid = as.factor(sid),
v_response = as.integer(v_response),
v_targetdeck = as.integer(v_targetdeck),
v_netchange = as.numeric(v_netchange),
latency = as.numeric(latency)
)
RTbound <- as.numeric(RTbound_ms) / 1000  # Convert to seconds
# Convert latency to seconds
data$RT <- data$latency / 1000
if (rt_method == "remove") {
# Remove trials with RT < RTbound
data <- data[data$RT >= RTbound, ]
} else if (rt_method == "force") {
# Force RTs below bound to be equal to bound
data$RT[data$RT < RTbound] <- RTbound
}
# For "adaptive" method, we'll handle it in the main function
# Reset trial numbers
data <- data %>%
group_by(sid) %>%
mutate(trial = row_number()) %>%
ungroup()
return(data)
}
# EXTRACT PARAMETERS
# Extract base name of a parameter
get_base_name <- function(param) {
gsub("_pr$", "", gsub("\\[.*\\]", "", param))  # Remove indices and _pr suffix
}
# Check if a parameter has indices
has_indices <- function(param) {
grepl("\\[", param)
}
# Categorize parameters
categorize_params <- function(params, hier_params_vec, main_params_vec, output_params_vec) {
base_names <- sapply(params, get_base_name)
hier_params <- base_names[sapply(base_names, function(p) any(sapply(hier_params_vec, function(h) grepl(paste0("^", h), p))))]
main_params <- base_names[base_names %in% main_params_vec]
output_params <- base_names[base_names %in% output_params_vec]
other_params <- setdiff(base_names, c(hier_params, main_params, output_params))
list(hier = hier_params, main = main_params, output = output_params, other = other_params)
}
sample_params <- function(params, sampled_indices) {
if (length(params) < 1){
return(c())
} else if (length(names(params)) < 1) {
return(params)
}
sampled_params <- c()
# Split parameters into base names and indices
param_split <- strsplit(names(params), "\\[")
base_names <- sapply(param_split, `[`, 1)
# Group parameters by their base name
param_families <- split(names(params), base_names)
for (family in param_families) {
indexed_params <- family[grepl("\\[", family)]
non_indexed_params <- unname(family[!grepl("\\[", family)])
if (length(indexed_params) > 0) {
# For parameters with indices
sampled_indexed <- indexed_params[sampled_indices]
sampled_params <- c(sampled_params, non_indexed_params, sampled_indexed)
} else {
# For parameters without indices, include all
sampled_params <- c(sampled_params, unname(family)[[1]])
}
}
return(sampled_params)
}
# Main function
extract_params <- function(param_names, n_subs, num_to_view = 10, drop_lp = TRUE,
hier_params_vec = c("mu", "sigma", "mu_"),
main_params_vec = NULL,
output_params_vec = NULL) {
# Remove "lp__" if drop_lp is TRUE
if (drop_lp) {
param_names <- param_names[param_names != "lp__"]
}
categorized_params <- categorize_params(param_names, hier_params_vec, main_params_vec, output_params_vec)
# Outside sample_params, after categorizing:
sampled_indices_other <- sort(sample(1:num_to_view, num_to_view))
sampled_indices_subs <- sort(sample(1:n_subs, num_to_view))
sampled_indices_trials <- sort(sample(1:n_trials, num_to_view))
# Sample and combine parameters
sampled_params <- c(
sample_params(categorized_params$hier, sampled_indices_other),
sample_params(categorized_params$main, sampled_indices_subs),
sample_params(categorized_params$output, sampled_indices_trials),
sample_params(categorized_params$other, sampled_indices_other)
)
# Sort parameters
sort_params <- function(params, hier_params_vec, main_params_vec, output_params_vec) {
param_order <- function(param) {
base_param <- get_base_name(param)
hier_index <- which(sapply(hier_params_vec, function(h) grepl(paste0("^", h), base_param)))
if (length(hier_index) > 0) return(hier_index[1])
main_index <- which(main_params_vec == base_param)
if (length(main_index) > 0) {
return(length(hier_params_vec) + 2 * main_index[1] - (if(grepl("_pr$", param)) 1 else 0))
}
output_index <- which(output_params_vec == base_param)
if (length(output_index) > 0) {
return(length(hier_params_vec) + 2 * length(main_params_vec) + output_index[1])
}
return(1000)  # If not found in any category, put at the end
}
params[order(sapply(params, param_order))]
}
sorted_params <- sort_params(sampled_params, hier_params_vec, main_params_vec, output_params_vec)
# Remove duplicates while preserving order
sorted_params <- sorted_params[!duplicated(sorted_params)]
return(sorted_params)
}
data_to_extract = c("T", "choice", "shown", "outcome", "is_pos", "is_neg", "shown_mat", "decay_str")
data_list = extract_sample_data(sample_df,data_to_extract)
data_list
data_list = extract_sample_data(sample_df, data_to_extract, n_trials = 10)
data_list
calculate_decay_str(data, data_list, is_group, n_trials)
calculate_decay_str(data, data_list, FALSE, n_trials)
calculate_decay_str(data, data_list, FALSE, 10)
data
calculate_decay_str(sample_df, data_list, FALSE, 10)
data_list
calculate_decay_str(sample_df, data_list, FALSE, 10)
sub_data = sample_df
T = 10
index_matrix <- outer(0:(T-1), 0:(T-1), `-`)
index_matrix[index_matrix < 0] <- 0
cumulative_effect_exp <- index_matrix
cumulative_effect_exp
shown_mat <- do.call(rbind, lapply(sub_data$v_targetdeck, function(x) t(as.numeric(as.matrix(1:4 == x)))))
shown_mat
shown_mat_ev <- shown_mat * (as.integer(sub_data$v_response) - 1)
shown_mat_ev
shown_mat
shown_mat[,,T]
shown_mat[,T]
shown_mat[T,]
shown_mat[1:T,]
shown_mat_ev = shown_mat_ev[1:T,]
shown_mat_ev
modified_cumulative_effect_exp <- array(0, dim=c(T, T, 4))
modified_cumulative_effect_exp
for (deck in 1:4) {
update_indices <- which(shown_mat_ev[, deck] != 0)
if (length(update_indices) > 0) {
perm_matrix <- create_permutation_matrix(update_indices, T)
modified_cumulative_effect_exp[,,deck] <- t(cumulative_effect_exp) %*% t(perm_matrix)
}
}
modified_cumulative_effect_exp
shown_mat_ev
modified_cumulative_effect_exp[,,1]
perm_matrix
update_indices
deck = 1
update_indices <- which(shown_mat_ev[, deck] != 0)
update_indices
perm_matrix <- create_permutation_matrix(update_indices, T)
perm_matrix
modified_cumulative_effect_exp[,,deck] <- t(cumulative_effect_exp) %*% t(perm_matrix)
modified_cumulative_effect_exp[,,d]
modified_cumulative_effect_exp[,,deck]
create_permutation_matrix(update_indices, T)
t(cumulative_effect_exp) %*% t(perm_matrix)
t(cumulative_effect_exp) %*% perm_matrix
t(cumulative_effect_exp) %*% t(perm_matrix)
cumulative_effect_exp %*% t(perm_matrix)
cumulative_effect_exp %*% perm_matrix
perm_matrix %*% cumulative_effect_exp
perm_matrix %*% t(cumulative_effect_exp)
t(perm_matrix) %*% cumulative_effect_exp
t(perm_matrix) %*% t(cumulative_effect_exp)
perm_matrix %*% cumulative_effect_exp
update_indices
perm_matrix <- matrix(0, nrow=T, ncol=T)
start <- update_indices[i]
start
end <- if (i < length(update_indices)) update_indices[i+1] - 1 else T
end
create_permutation_matrix <- function(update_indices, T) {
perm_matrix <- matrix(0, nrow=T, ncol=T)
for (i in 1:length(update_indices)) {
start <- update_indices[i]
end <- if (i < length(update_indices)) update_indices[i+1] - 1 else T
perm_matrix[start:end, start] <- 1
}
return(perm_matrix)
}
create_permutation_matrix(update_indices, T)
t(cumulative_effect_exp) %*% t(perm_matrix)
cumulative_effect_exp
t(cumulative_effect_exp) %*% t(perm_matrix)
perm_matrix
perm_matrix = create_permutation_matrix(update_indices, T)
t(cumulative_effect_exp) %*% t(perm_matrix)
perm_matrix
t(perm_matrix)
cumulative_effect_exp
cumulative_effect_exp %*% t(perm_matrix)
t(cumulative_effect_exp)
t(cumulative_effect_exp) %*% t(perm_mat)
t(cumulative_effect_exp) %*% t(perm_matrix)
t(cumulative_effect_exp)
t(perm_matrix)
data_list$decay_str
(1 - update)^data_list$decay_str
update
(1 - .2)^data_list$decay_str
data_list$shown_mat
(1 - .2)^data_list$decay_str * data_list$shown_mat
(1 - .2)^data_list$decay_str .* data_list$shown_mat
((1 - .2)^data_list$decay_str) .* data_list$shown_mat
((1 - .2)^data_list$decay_str) %*% data_list$shown_mat
((1 - .2)^data_list$decay_str) %*% t(data_list$shown_mat)
dim(data_list$shown)
dim(data_list$shown_mat)
dim((1 - 0.2)^data_list$decay_str)
ace = (1 - 0.2)^data_list$decay_str
ace
ace[1]
ace[,1]
ace[,,1]
ace[,,1]
ace[,,1] %*% data_list$shown_mat
ace[,,1] %*% data_list$shown_mat[1]
ace[,,1] * data_list$shown_mat[1]
########
# Create the base cumulative effect matrix
index_matrix <- outer(0:(T-1), 0:(T-1), `-`)
ace[,,1] * data_list$shown_mat[1]index_matrix
index_matrix
index_matrix[index_matrix < 0]
index_matrix[index_matrix < 0] = NA
# Create the base cumulative effect matrix for one sub
index_matrix <- outer(0:(T-1), 0:(T-1), `-`)
index_matrix[index_matrix < 0] <- NA
cumulative_effect_exp <- index_matrix
cumulative_effect_exp
modified_cumulative_effect_exp <- array(0, dim=c(T, T, 4))
for (deck in 1:4) {
update_indices <- which(shown_mat_ev[, deck] != 0)
if (length(update_indices) > 0) {
if (length(update_indices) > 0) {
perm_matrix <- create_permutation_matrix(update_indices, T)
modified_cumulative_effect_exp[,,deck] <- t(cumulative_effect_exp) %*% t(perm_matrix)
}
}
}
modified_cumulative_effect_exp
shown_mat_ev = shown_mat * (as.integer(sample_df$v_response) - 1)
modified_cumulative_effect_exp <- array(0, dim=c(T, T, 4))
for (deck in 1:4) {
update_indices <- which(shown_mat_ev[, deck] != 0)
if (length(update_indices) > 0) {
if (length(update_indices) > 0) {
perm_matrix <- create_permutation_matrix(update_indices, T)
modified_cumulative_effect_exp[,,deck] <- t(cumulative_effect_exp) %*% t(perm_matrix)
}
}
}
cumulative_effect_exp
update_indices
shown_mat
shown_mat[1:10,]
shown_mat = shown_mat[1:10,]
shown_mat_ev = shown_mat * (as.integer(sample_df$v_response) - 1)
shown_mat_ev = shown_mat * (as.integer(sample_df$v_response) - 1)[1:10]
shown_mat_ev
modified_cumulative_effect_exp <- array(0, dim=c(T, T, 4))
deck = 1
update_indices <- which(shown_mat_ev[, deck] != 0)
update_indices
decay_exponents <- array(0, dim=c(4, T, T))
decay_mask <- array(0, dim=c(4, T, T))
update_indices
perm_matrix <- create_permutation_matrix(update_indices, T)
perm_matrix
t(cumulative_effect_exp) %*% t(perm_matrix)
t(upper.tri(matrix(1, T, T), diag=TRUE)) %*% t(perm_matrix)
t(upper.tri(matrix(1, T, T), diag=TRUE))
t(cumulative_effect_exp)
t(cumulative_effect_exp) %*% t(perm_matrix)
t(perm_matrix)
t(cumulative_effect_exp) %*% perm_matrix
cumulative_effect_exp %*% t(perm_matrix)
t(cumulative_effect_exp) %*% t(perm_matrix)
t(cumulative_effect_exp)
t(cumulative_effect_exp) %*% perm_matrix
t(cumulative_effect_exp) %*% t(perm_matrix)
t(cumulative_effect_exp) * t(perm_matrix)
t(cumulative_effect_exp) * perm_matrix
cumulative_effect_exp * t(perm_matrix)
t(cumulative_effect_exp) * perm_matrix
cumulative_effect_exp * t(perm_matrix)
t(perm_matrix) * cumulative_effect_exp
t(perm_matrix) * t(cumulative_effect_exp)
t(perm_matrix) %*% t(cumulative_effect_exp)
t(perm_matrix) %*% cumulative_effect_exp
perm_matrix %*% t(cumulative_effect_exp)
perm_matrix %*% cumulative_effect_exp
cumulative_effect_exp * t(perm_matrix)
t(perm_matrix)
cumulative_effect_exp %*% t(perm_matrix)
cumulative_effect_exp
t(cumulative_effect_exp)
t(cumulative_effect_exp) %*% t(perm_matrix)
t(cumulative_effect_exp) * t(perm_matrix)
t(cumulative_effect_exp) * t(perm_matrix)
t(cumulative_effect_exp)
t(cumulative_effect_exp) * perm_matrix
t(perm_matrix)
t(perm_matrix)
t(cumulative_effect_exp) %*% t(perm_matrix)
t(cumulative_effect_exp) * t(perm_matrix)
getwd()
library(plyr)
library(dplyr)
library(ggplot2)
library(gridExtra)
library(grid)
library(kableExtra)
library(tidyr)
library(here)
library(foreign)
library(bayesplot)
library(posterior)
library(rstan)
library(plyr)
library(dplyr)
library(ggplot2)
library(gridExtra)
library(grid)
library(kableExtra)
library(tidyr)
library(here)
library(foreign)
library(bayesplot)
library(posterior)
library(rstan)
# List of required packages
required_packages <- c("plyr", "dplyr", "ggplot2", "gridExtra", "grid", "kableExtra",
"tidyr", "here", "foreign", "bayesplot", "posterior", "rstan")
# Check and install missing packages
install_if_missing(required_packages)
# Load required packages
lapply(required_packages, library, character.only = TRUE)
# Load required packages
# Function to check and install packages
install_if_missing <- function(packages) {
new_packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new_packages)) {
cat("Installing missing packages:", paste(new_packages, collapse=", "), "\n")
install.packages(new_packages, repos="https://cran.rstudio.com/")
}
}
# List of required packages
required_packages <- c("plyr", "dplyr", "ggplot2", "gridExtra", "grid", "kableExtra",
"tidyr", "here", "foreign", "bayesplot", "posterior", "rstan")
# Check and install missing packages
install_if_missing(required_packages)
